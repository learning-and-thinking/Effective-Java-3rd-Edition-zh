# 第 18 条：复合优于继承

继承是实现代码复用的一个有效方法，但并不总是实现代码复用的最好方法。继承使用不当，会导致系统非常脆弱。在同一个包的作用域下使用继承是安全的，因为子类和父类的实现都在同一个程序员的控制之下；或者，继承一个设计规范并且有扩展文档的类也是安全的。然而，跨包边界继承普通类是危险的。提醒一下，本书中使用的继承（inheritance）特指实现继承（*implementation inheritance*），一个类继承另一个类的情况。本条中讨论的问题不适用于接口继承（*interface inheritance*），类实现接口或接口继承另一个接口。

**与调用方法不同，继承会破坏封装**。换句话说，子类依赖于父类的实现细节。父类的实现可能会随着版本的迭代而发生变化，当父类代码改变时，即使子类的代码没有发生变化，子类也可能被破坏而失去其本身的功能。因此，子类必须随着父类的变化而调整，除非父类的作者提前为相应的扩展做了设计并记录在文档里。

举个例子，假设我们有一个程序用到了 HashSet。为了调整程序性能，我们需要查询 HashSet 自创建以来添加了多少元素（不要与当前大小混淆，当前大小会随着元素的删除而减少）。为了提供这个功能，我们编写了一个 HashSet 变体来记录元素插入次数，并提供了一个接口供外部访问该累加量。HastSet 类包含两个添加元素的方法：add 和 addAll，因此我们重写了这两个方法：

```java
// 错误 - 继承使用不当！
public class InstrumentedHashSet<E> extends HashSet<E> {
  // 元素添加次数
  private int addCount = 0;
  
  public InstrumentedHashSet() {
  }
  
  public InstrumentedHashSet(int initCap, float loadFactor) {
    super(initCap, loadFactor);
  }
  
  @Override
  public boolean add(E e) {
    addCount++;
    return super.add(e);
  }
  
  @Override
  public boolean addAll(Collection<? extends E> c) {
    addCount += c.size();
    return super.addAll(c);
  }
  
  public int getAddCount() {
    return addCount;
  }
}
```

这个类看起来很合理，但并不能实现想要的效果。假设我们创建了一个实例，并使用 addAll 方法添加了 3 个元素。顺便提一次，我们使用 `List.of` 创建了一个列表，该方法是在 Java 9 中添加的；如果使用的是早期版本，请改用 `Arrays.asList` ：

```java
InstrumentedHashSet<String> s = new InstrumentedHashSet<>();
s.add(List.of("Snap", "Crackle", "Pop"));
```

我们期待的效果是 `getAddCount` 方法返回 3，但它实际上会返回 6。哪里出错了呢？实际上，HashSet 内部 addAll 方法是在其 add 方法之上实现的，这种实现方法相当合理，尽管 HashSet 文档上没有记录这个实现细节。InstrumentedHashSet 的 addAll 方法执行了 addCount 值加 3，然后通过 `super.addAll` 调用了父类 HashSet 的 addAll 方法。这反过来又为每个元素调用一次在 `InstrumentedHashSet` 中被覆盖的 `add` 方法。这三次调用中的每一次都执行了 addCount 值加一，addCount 总共加 6：使用 addAll 方法添加的每个元素都加了两遍 addCount 的值。

我们可以通过去除`InstrumentedHashSet`子类中重写的 addAll 方法来解决这个问题。虽然结果正确，但它的正确性依然取决于 HashSet 中的 addAll 方法是在其 add 方法之上实现的这一事实。这种”自用(self-use)“是实现细节，不能保证在 Java 平台的所有实现中都适用，并且会随着版本的变化而变化。因此，将会导致`InstrumentedHashSet`类的脆弱性。





